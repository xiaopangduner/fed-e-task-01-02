## 简答题

1. 输出结果为10
```javascript
// 1、创建全局变量a，a为空数组   
var a = []
// 开始循环
// 2、创建全局变量i，初始为0，最大为10，随循环自增
for (var i = 0; i < 10; i++) {
    // 3、为匿名函数分配内存，并将匿名函数地址赋值给a[i]
    a[i] = function () {
        // 5、在作用域链中查找变量i，自身作用域中不存在i，向全局作用域查找，得到全局作用域的变量i，此时i的值为10，打印i
        console.log(i)
    }
}
// 4、获取a[6]存储的匿名函数地址，调用匿名函数
a[6]()
```

2. 控制台报错，tmp变量不存在

   ```javascript
   // 1、创建全局变量tmp，tmp值为123
   var tmp = 123
   // 2、进入if条件判断，条件为true，直接通过
   if (true) {
       // 3、在作用域链中查找tmp变量。先在自身作用域中查找，发现有使用let关键字声明的tmp变量
       console.log(tmp)
       // 4、let、const关键字声明的变量不会进行变量提升，并且对当前作用域暂时锁死，直到声明完成，所以打印报错
       let tmp
   }
   ```

3. 查找数组最小值ES5中需要对数组进行循环比对。ES6中增加了扩展运算符...，可以和Math.min结合。

   ```javascript
   var arr = [12, 34, 32, 89, 4]
   Math.min(...arr)
   ```

4. + var关键字创建的变量是全局变量；let、const关键字创建的变量是局部变量。
   + var关键字创建的变量存在变量提升；let、const关键字创建的变量不存在变量提示，并且会造成暂时死区。
   + let、var关键字创建的变量可以进行修改；const关键字创建的变量是常量，不可以进行修改，对于引用类型数据，可以修改数据属性。
   + var关键字创建的变量在同一作用域内可多次声明；let、const关键字创建的变量在同一作用域内不可多次声明。

5. 输出结果为20

   ```javascript
   // 1、创建全局变量a，a的值为10
   var a = 10
   // 2、创建全局变量obj，obj属性a的值为20，obj的属性fn值为函数地址
   var obj = {
       a: 20,
       fn () {
           // 4、执行fn，进入定时器，定时器运行在与当前函数完全分离的环境，会对this指向产生影响
           setTimeout(() => {
               // 5、定时器中执行的函数是箭头函数，this总是指向调用者，即obj，输出obj的属性a的值20
               console.log(this.a)
           })
       } 
   }
   // 3、调用fn函数，调用者为obj
   obj.fn()
   ```

6. Symbol是es6中新增的一种基本数据类型，它表示一个独一无二的值，Symbol具有静态属性和静态类型。Symbol()函数返回Symbol类型的值。

   + 如果使用Symbol类型的数据作为对象的key，Symbol类型的key无法通过枚举来找到，使用JSON.stringify将对象转成字符串的时候，Symbol类型的key也不会在输出内容中。利用这个特性，对象中不需要对外操作和访问的属性就可以使用Symbol类型，创建更加合理的数据结构。
   + 当需要用一组唯一的常量来表示一组类型的时候，可以使用Symbol类型的数据来代替常量。

   

7. 浅拷贝和深拷贝是针对引用类型才有的概念。引用类型的数据存储的是数据的引用地址；浅拷贝复制的是存储的引用地址，当修改原数据的属性时，新数据也会跟着改变；深拷贝则开辟新的存储空间，递归拷贝数据数据中的引用，直到子属性是基本类型为止，当修改原数据的属性时，新数据不会跟着修改。

   

8. javascript是一门可以运用在html上的弱类型的动态脚本语言。typescript是由微软开发的面向对象语言，typescript是javascript的超集，包含了javascript的所有元素，typescript最终编译后仍然是javascript代码。typescript中增加了对数据类型的严格要求，扩展了javascript中的数据类型，typescript中增加了静态类型、类、模块、接口和类型注解。

   

9. 优点：

   + 增加了代码的可读性和可维护性。typescript对数据类型定义的严格要求，可以直接了解该数据、函数的作用。typescript在编译时就能发现大部分错误，能更好的处理代码中存在的问题。

   + 有着极强的包容性。typescript可以直接运行javascript代码，不对数据类型进行定义的时候可以自动进行类型推断。编译阶段即使报错也能生成javascript代码。可以兼容第三方库。

   + 拥有活跃的社区。Angular2、Vue3.0都使用typescript进行开发。大部分第三方库都可以为typescript提供类型定义文件。typescript完全拥抱ES6规范。

     

10. 引用计数会跟踪记录每个值被引用的次数。当声明一个变量并且将一个引用类型的值a赋值给该变量的时候，a的引用次数就是1；当a的应用再次赋值给其他变量的时候，a的引用次数加一；如果包含a的引用的变量被另外一个值b赋值了，a的引用次数减一。当a的引用次数为0的时候，再垃圾回收器下一次运行时，就会是否a所占的内存。

    + 优点：发现垃圾时能立即回收，最大程度减少程序暂停。
    + 缺点：无法回收循环引用的空间，资源消耗大。

    

11. + 遍历所有对象，并且对活动对象进行标记
    + 对被标记的对象进行整理，将被标记的对象移动到连续的地址
    + 遍历所有对象，并且对没有标记的对象进行清除
    + 回收被清除的对象所占用的空间

    

12. + 新生代存储区平分为两个区域from和to，各占16M，from为使用状态，to为空闲状态
    + 通过标记整理算法回收过垃圾后，将活动对象拷贝到to区域
    + 如果有上一轮GC后存留下来的对象或者是to区域的使用率超过25%，则发生晋升，即将新生代对象移动到老生代
    + from和to的区域互换，完成回收

    

13. javascript是在主线程上执行的，所以执行垃圾回收算法的时候，当前运行的javascript脚本就必须要停下，等待回收完成之后再继续执行。这种情况在新生代存储区中影响并不明显，新生代中的空间较少，并且存活的对象不多。可是放到老生代存储区的时候，脚本停顿时间就会对用户体验造成明显影响，这个时候就需要引入增量标记算法了。

    + v8引擎将一次回收任务分成多个小的任务
    + javascript脚本与分割的回收任务交替进行，由于任务被分割了，每个任务的执行时所产生的javascript脚本停顿时间不会造成明显影响